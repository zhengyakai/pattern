装饰器模式（Decorator Pattern）
允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，
它是作为现有的类的一个包装（目的是增强）。

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

看类图，Component 是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象，比
如上面的成绩单，记住在装饰模式中，必然有一个被提取出来最核心、最原始、最基本的接口或抽象类，
就是 Component。
ConcreteComponent 这个事最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是这个东东。
Decorator 一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，
在它的属性里必然有一个 private 变量指向 Component。
ConcreteDecoratorA 和 ConcreteDecoratorB 是两个具体的装饰类，你要把你最核心的、最原始的、最
基本的东西装饰城啥东西，例子就是把一个比较平庸的成绩单装饰成家长认可的成绩单。

装饰模式是对继承的有力补充，要知道继承可不是万能的，继承可以解决实际的问题，但是在项目
中你要考虑诸如易维护、易扩展、易复用等，而且在一些情况下（比如上面那个成绩单例子）你要是用继
承就会增加很多了类，而且灵活性非常的差，那当然维护也不容易了，也就是说装饰模式可以替代继承，
解决我们类膨胀的问题，你要知道继承是静态的给类增加功能，而装饰模式则是动态的给增加功能，你看
上面的那个例子，我不想要 SortDecorator 这层的封装也很简单呀，直接在 Father 中去掉就可以了，如果
你用继承就必须修改程序。

装饰模式还有一个非常好的优点，扩展性非常好，在一个项目中，你会有非常多因素考虑不到，特别
是业务的变更，时不时的冒出一个需求，特别是提出一个令项目大量延迟的需求时候，
装饰者模式可以给我们提供很大帮助。